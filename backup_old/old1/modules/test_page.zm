/******************************************************************************\
FILE:           test_page.zm
AUTHOR:         Theo Veenker <theo.veenker@beexy.nl>
ADAPTED BY:     Chris van Run

DESCRIPTION:

Provides a page object to show to the participant during test trials.
It handles presenting the stimulus and recording the participant's response.


HISTORY:
2011-10-25 TV   Created.
2014-08-19 CvR  Adjusted to incorporate button box.

\******************************************************************************/

import std_sound_output_device;


Page test_page
{
    TestItem    item;           // trial control parameters
    int        key_left;           // key for right button
    int        key_right;          // key for left button
    color       color_left;
    color       color_right;

    init()
    {
        fill_pattern_color = TEST_PAGE_COLOR;
    }

    on_event:key_press()
    {
        // Handle space and Enter keys.
        if(input_key == KEY_Escape)
        {
            done(CONTINUE);
        }
        else if (input_key == KEY_Shift_L)
        {
            response.process_hit(key_left, event_time);
        }
        else if (input_key == KEY_Shift_R)
        {
            response.process_hit(key_right, event_time);
        }
        else
            handle_special_key(this, input_key, input_modifiers);
    }

    VerticalLayout layout
    {
        init()
        {
            spacing = 50;
            height = 0;     // 0 means as large as possible
        }

         CanvasGadget canvas
        {
            init()
            {
                fill_pattern_color = TEST_PAGE_COLOR;
                size = 450, 100;
                offset_x = round(width / 2);
                offset_y = round(height / 2);
            }
 
            CrossShape fixation
            {
                init()
                {
                    radius = 30;
                    line_width = 5;
                    line_pattern_color = color:white;
                }
            }
        }

        HorizontalLayout buttons
        {
            init()
            {
                spacing = 200;
            }


            ButtonGadget button1
            {
                init()
                {
                    font_family = INPUT_PAGE_BUTTON_FONT_FAMILY;
                    font_size = INPUT_PAGE_BUTTON_FONT_SIZE;
                    fill_pattern_color = color:lightgreen;
                    border_color = color:gray60;
                    text_color = INPUT_PAGE_BUTTON_TEXT_COLOR;
                    margin = 15;
                    border = 6;
                }

                on_event:activate()
                {
                    response.process_hit(key_left, event_time);
                }
            }


            ButtonGadget button2
            {
                init()
                {
                    font_family = INPUT_PAGE_BUTTON_FONT_FAMILY;
                    font_size = INPUT_PAGE_BUTTON_FONT_SIZE;
                    
                    border_color = color:gray60;
                    text_color = INPUT_PAGE_BUTTON_TEXT_COLOR;
                    margin = 15;
                    border = 6;
                }

                on_event:activate()
                {
                    println(border);
                    response.process_hit(key_right, event_time);
                }
            }
        }

        void start_fix(time t, time end)
        {
            canvas.fixation.start(t);
            canvas.fixation.stop(end);
        }

        void reset()
        {
            hide_buttons();
            layout.buttons.button1.border_color = color:gray60;
            layout.buttons.button1.fill_pattern_color = color_left;
            layout.buttons.button2.border_color = color:gray60;
            layout.buttons.button2.fill_pattern_color = color_right;

        }
    }


    SoundChain audio
    {
        // Sound source/producer object.
        SoundSequence seq
        {
            SoundFile sound1 {}
        }      

        // Sound sink/consumer object.
        SoundPlayback playback {}

        void play(time tstart)
        {
            abort();

            playback.device = sound_output_device;
            seq.sound1.file = stimuli_dir() + "sounds/" + item.sound_fnm;
            seq.sound1.trailer_duration = SOUND_TRAILER_DURATION;

            start(tstart);
        }
    }

    // Aborts any ongoing activity on this page and signals the initiator
    // of the trial that we're done.
    void done(int msgid)
    {
        // Just in case; abort presentation if still active.
        audio.abort();

        signal_target(msgid);   // tell caller we're done
        target = null;

        control.button_box.disable_buttons();
        control.target = null;
        control.clear_status();
    }


    // Performs cleaning up if necessary.
    void cleanup()
    {
    }

    void set_label_texts(string s1, string s2)
    {
        layout.buttons.button1.text = s1;
        layout.buttons.button2.text = s2;
    }

    void show_buttons()
    {
        layout.buttons.is_visible = true;
    }


    void hide_buttons()
    {
        layout.buttons.is_visible = false;
    }

    void set_keys(int k_l, int k_r)
    {
        key_left = k_l;
        key_right = k_r;
    }

    void set_colors(color c_l, color c_r)
    {
        color_left = c_l;
        color_right = c_r;
    }

     Response response
    {
        int     goodvalue;      // correct answer to question (0 if n.a.)
        int     value;          // response value: 1..2 (0 on timeout)
        int     rt;             // response time [ms]
        bool    correct;        // true if correct answer given (if applicable)

        on_event:start()
        {
            show_buttons();
        }

        void clear()
        {
            goodvalue = 0;
            value = 0;
            rt = -9999;
            correct = false;
        }


        void process_hit(int val, time t)
        {
            if(val == key_left)
            {
               layout.buttons.button1.border_color = color:white;
            } else
            {
                layout.buttons.button2.border_color = color:white;
            }

            if (hit(t) == HIT_VALID)
            {
                value = val;
                rt = int(reaction_time(0));
                correct = val == goodvalue;

                ignore_remaining_hits();

                stop(now() + 200ms);
            }
        }

        on_event:finish()
        {
            done(CONTINUE);
        }
    }

    // Starts a trial.
    void action(Object caller, TestItem it, time tref)
    {
        // Save the passed trial control parameters.
        item = it;

        layout.reset();
        
        // Show this page (if not yet done) and make tref the trial start time.
        tref = test_window1.show_test_page(this, tref + INTERTRIAL_INTERVAL);
        
        // Start the sound stimulus. Duration depends on actual length of 

        audio.play(tref+DELAY_FIXATION_SOUND);
        layout.start_fix(tref, audio.expected_finish_time);

        response.clear();
        response.goodvalue = item.expected_answer;
        response.start(audio.expected_finish_time);
        
        // Enable button-box buttons.
        control.target = this;
        control.button_box.disable_buttons();
        control.button_box.enable_button(0,key_left);
        control.button_box.enable_button(2,key_right);

        // Update status line on control window. Cleared in done() above.
        control.set_status(
            string(item.id) + "  " + 
            string(item.sound_fnm) + "  " + 
            string(item.expected_answer));


        // Remember who to signal when the trial is over.
        target = caller;
    }
}
